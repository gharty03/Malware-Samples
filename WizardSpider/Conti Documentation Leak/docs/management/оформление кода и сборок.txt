ТРЕБОВАНИЯ К КОДУ

1. Нужно минимизировать использование Visual C++ Runtime. Функции malloc, memcpy, str* - следует избегать.
В WinAPI уже есть все необходимое – вместо malloc – HeapAlloc, вместо memcpy – CopyMemory, вместо strstr – StrStr (shlwapi.h/.lib).
CRT добавляет достаточно много лишнего кода к бинарнику.
1.1. STL в общем случае следует избегать.
1.2. Некоторые фичи STL дают дополнительный пролог к коду. Для std::mutex он весит 200к. Его не видно в вашем коде, а он есть, и будет вести себя странно в контексте выполнения!
2. Линковка рантайма и сторонних библиотек к модулю должна быть статической (флаг /MT). 
3. Строки обфусцировать библиотекой Andrivet (приложена, см.макрос _STR())
4. Системные вызовы обфусцировать библиотекой GetApi.h. Быть внимательным, обфускация сисвызовов может давать падения.


ОФОРМЛЕНИЕ МОДУЛЯ

1. Должен иметься проект Microsoft Visual Studio версии не ниже 2015.
2. Проект Visual Studio должен быть настроен следующим образом:
* Для ВСЕХ профилей сборки:
- Общие / Выходной каталог: $(SolutionDir)Bin\$(PlatformTarget)\$(Configuration)\
- Общие / Промежуточный каталог: $(SolutionDir)\obj\$(Platform)\$(Configuration)\$(ProjectName)\
- Общие / Версия пакета SDK для Windows: <наследовать от родителя или значений по умолчанию проекта>
- С/С++ / Общие / Многопроцессорная компиляция: да
- С/С++ / Создание кода / Библиотека времени выполнения: Многопоточная или Многопоточная отладка (Release/Debug соответственно)
- С/С++ / Создание кода / Создать образ с обновлением: Нет
- С/С++ / Создание кода / Включить С/С++ исключения: Нет
* Профиль Release:
- Формат отладочной информации (С/С++ Общие ): нет
- Создавать отладочную информацию (компоновщик/отладка): нет
В дополнительные параметры добавить
/DEBUG:NONE /EMITPOGOPHASEINFO
https://stackoverflow.com/questions/45538668/remove-image-debug-directory-from-rdata-section
- С/С++ / Создание кода / Включить проверку безопасности: нет
- С/С++ / Создание кода / Основные проверки времени выполнения: по умолчанию
- С/С++ / Оптимизация / Опустить указатели на фреймы: да
* При сборке LLVM-Obfuscator:
Clang добавляет строку с путем к файлу символов .pdb, даже если это отключено опциями сборки.
Подавлять так (Visual Studio):
- Компоновщик -> Командная строка, указать /pdbaltpath:<строка>, вместо пути к pdb будет эта строка.
5. Модуль должен иметь две версии - x32- и x64-разрядную.
6. Модуль должен быть скомпонован статически и представлять из себя один файл .exe/.dll.
Для модулей .dll допускается прилагать _тестовую_ запускалку в виде .exe.
7. В боевой сборке должны быть обфусцированы по максимуму строки, отключен всяческий отладочный вывод.
8. Модуль должен иметь отладочную версию. Отладочный вывод должен выводиться в modulename.log (путь к логу настраивается в макросе).
Каждая запись лога должна содержать временнУю метку с точностью до секунды.
9. В проекте должен быть файл настроек config.h (название неважно, важна суть - здесь все глобальные настройки - пути, макросы-переключатели условной компиляции итд).
10. Модуль должен работать на всех современных версиях Windows.
   Минимальная поддерживаемая версия Windows - Windows XP (если невозможно - Windows Vista).
11. Дополнительно к компоновке должен добавляться файл notelemetry.obj (https://stackoverflow.com/questions/37761768/how-to-prevent-visual-studio-2015-update-2-to-add-telemetry-main-invoke-trigger)
12. Точка входа для Cobalt Strike:
#define DLL_API __declspec(dllexport)
extern "C" DLL_API void CALLBACK StartDLL(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
Вызывается так:

TStr DllCmdLine;
for(int i = 1; i < argc; i++)
    DllCmdLine += TStr(argv[i]) + (i < argc - 1 ? " " : "");
char *OutputData;
int OutputSize;
int *p = &OutputSize;
pStartDLL(HWND(&OutputData), HINSTANCE(&OutputSize), &DllCmdLine[0], SW_MAX + 1);
Точка входа блокирующая: вызывающий контекст можно блокировать на любое время, необходимое для завершения функции.

ОФОРМЛЕНИЕ СБОРОК

В сборке должна быть структура каталогов:

 modulename/Release_logged/x86
 modulename/Release_logged/x64
 modulename/Release_nologs/x86
 modulename/Release_nologs/x64

В Release_logged идет версия с логом и без обфускации (но это все равно профиль сборки Release!
т.е. там должны быть включены все оптимизации, выключены отладочные символы итд).
В release_nologs - версия без лога, с полной обфускацией.
В имени каталога со сборкой должно быть имя модуля и дата (например cookies.22.04.2019).
Если на указанную дату есть несколько сборок одного модуля, должен добавляться уникальный суффикс (например cookies.22.04.2019.2)

Это нужно для нормальной эксплуатации модуля - чтобы тестировщики и администраторы отличали версии сборок,
чтобы был возможно сделать откат или апгрейд, а также для выдачи нужной сборки по её дате.
Пример скрипта для автоматизированной публикации сборок приложен в конце документа.

К сборке должны обязательно прилагаться два файла на русском языке:

* README.txt - краткое описание назначения и использования программы.
Здесь должны быть указаны неочевидные нюансы, быстрый старт, все тонкости, о которых знает разработчик
и не знает посторонний.
Главное требование к документу: точность. Если в документе что-то заявлено, оно должно работать без вопросов в указанных рамках ограничений.

Примерная структура документа:
- Назначение программы
- Краткое описание
- Синтаксис
- Формат конфигов и настроек (если есть)
- Ограничения, известные ошибки и проблемы, поддерживаемые ОС и стороннее ПО, системные требования

* RELEASE_NOTES.txt в следующем формате:

11.02.2010
Версия 1.1
- новые фичи такие и такие
- такие баги исправлены
- такие баги известны и не были исправлены, но запланированы к исправлению
- такие нюансы использования версии

01.02.2010
Исправлено падение программы из-за того и этого

01.01.2010
Первая версия программы


ВАЛИДАЦИЯ СБОРОК

Перед выдачей сборки разработчик обязан:
- самостоятельно провести дымный тест
- проверить необфусцированные строки в бинарных файлах Release_nologs.
Это можно сделать как простым просмотром тела файла в Far,
так и с помощью IDA Pro (после окончания разбора файла открываем Open Subview -> Strings),
так и сторонними утилитами.
- В особенности нужно убедиться в отсутствии никнеймов и путей в бинарниках
(по типу d:\work\Vasya Ivanov\project\project.pdb)
- проверить отсутствие ссылки на отладочную информацию в Release_nologs
(IDA Pro выдает окно с предложением подключить отладочные символы при начале разбора файла)
- проверить файл на dyncheck.com на статическом анализе. Динамический анализ НЕ ЗАПУСКАТЬ!
Допустимые показатели детектов:
* x86 - до 6-и детектов
* x64 - до 3-х детектов
!!!ЗАПРЕЩЕНО проверять детекты на virustotal.com!!!


ВЫДАЧА СБОРОК

Сборки выдаются в виде шифрованного архива .rar с длиной пароля не менее 16 символов.
Пароль должен быть стойким (разные регистры символов, альфа и цифры, знаки препинания итд).
ИМЕНА ФАЙЛОВ В АРХИВЕ ДОЛЖНЫ ШИФРОВАТЬСЯ.
Имя архива должно быть не говорящим.
modulename.22.09.2010.rar - плохое имя
c.rar - хорошее имя


ПОЛИТИКА GIT

В GIT КОММИТИТЬ ВСЯКИЙ РАЗ, КОГДА ЕСТЬ ЧТО.

ЭТО ЗАЛОГ ТОГО, ЧТО НЕ ПРОПАДЕТ РАБОТА.

ЭТО ЗАЛОГ ТОГО, ЧТО НЕ ПРОПАДЕТ РАБОТА.

ЭТО ЗАЛОГ ТОГО, ЧТО НЕ ПРОПАДЕТ РАБОТА.

Если каждый день пишешь код - значит каждый день коммитишь.
Коммитить нужно ДАЖЕ НЕРАБОЧИЙ код - просто делаем это в отдельную ветку, и вливаем ее в основную после стабилизации.

ЗАПРЕЩЕНО КОММИТИТЬ:
- архивы
- файлы с логинами, паролями, URL и IP-адресами, именами, адресами, телефонами кого-либо из знакомых, а также их хэшами
(это не касается случаев, когда файл взят из паблика, какого-нибудь демо, URL ведет в паблик, итд)
- бинарный мусор (файлы .obj, .suo, .sdf и прочие промежуточные файлы Visual Studio и других IDE)
- результаты сборки - выходные файлы проекта (.exe итд)

Зачем нужны системы контроля версий (и git в частности)
- как средство резервного копирования (страхует от пропажи работы за день)
- как средство централизованного хранения и мобильности кода (доступ из любой точки и с любой машины)
- память и история (ответ на вопрос: ПОЧЕМУ была написана ЭТА ДОЛБАНАЯ СТРОЧКА)

Поверь - через полгода максимум ты сам не вспомнишь, почему была написана эта долбаная строчка.
Если же проект достался тебе после кого-то - это mission impossible.
Для решения этой проблемы почти во всех современных средствах контроля версий есть функция blame.
Например

git blame src/file.cpp

покажет и автора, дату и номер коммита каждой строчки указанного файла. Причем все это интегрировано в Visual Studio
(правой мышью на файл в Solution Explorer -> Обвинение (заметки))
Для того, чтобы видеть там что-то внятное, вместо "some update", надо
- комменты для коммитов писать внятные;
- коммитить по паре строк за один раз, вместо коммита огромного пакована файлов в конце недели с комментарием ".";
- коммитить только те файлы, которые были затронуты в данном исправлении (а не херакнуть весь каталог с комментарием "commit", а что такого,
пофиг что туда подтянулось также старое забытое дерьмо, лежащее в проекте уже бох знает сколько)
- использовать инструмент diff (точнее его визуальный аналог, например merge tool встроенный в Visual Studio) при создании коммита

Из этого следует, что коммитить надо часто:
- исправил баг - сразу и закоммитил только касающиеся его файлы с комментом "исправлен баг такой-то по переполнению стека в функции такой-то потому-то и поэтому-то"
- написал фичу - сразу и закоммитил только касающиеся его файлы с комментом "реализация неинтерактивного HTTP-клиента"

И тогда, подымая историю изменений файла, ты будешь видеть ПРИЧИНУ написания данной строчки, а также ВЗАИМОСВЯЗЬ этой строчки с другими частями кода.

Можно конечно этого всего не делать, потому что лень учиться, нафиг и все такое.
Но кто ты тогда?


ПРИЛОЖЕНИЕ 1. СКРИПТ АВТОМАТИЧЕСКОЙ ПУБЛИКАЦИИ

Далее идет пример командного сценария .bat для публикации сборки.


@echo off
rem usage: publish_build.bat

SetLocal EnableDelayedExpansion
set outdir=f:\temp
set srcdir=f:\Projects\project\Bin

for /f %%x in ('wmic path win32_localtime get /format:list ^| findstr "="') do set %%x
set today=%Day%.%Month%.%Year%
set outdir=%outdir%\g%today%
echo %outdir%
if not exist %outdir% goto :startcopy
set /a x=2
:while
if %x% lss 100 (
  echo %x%
  set /a x+=1
  if not exist %outdir%.%x% (
     set outdir=%outdir%.%x%
     goto :startcopy
  )
  goto :while
)
)

:startcopy
mkdir %outdir%
mkdir %outdir%\logged
mkdir %outdir%\logged\Release.x86
mkdir %outdir%\logged\Release.x64
xcopy /Y %srcdir%\x86\Release_logged\module.dll %outdir%\logged\Release.x86
xcopy /Y %srcdir%\x86\Release_logged\loader-test.exe %outdir%\logged\Release.x86
xcopy /Y %srcdir%\x64\Release_logged\module.dll %outdir%\logged\Release.x64
xcopy /Y %srcdir%\x64\Release_logged\loader-test.exe %outdir%\logged\Release.x64

mkdir %outdir%\not_logged
mkdir %outdir%\not_logged\Release.x86
mkdir %outdir%\not_logged\Release.x64
xcopy /Y %srcdir%\x86\Release_nologs\module.dll %outdir%\not_logged\Release.x86
xcopy /Y %srcdir%\x86\Release_nologs\loader-test.exe %outdir%\not_logged\Release.x86
xcopy /Y %srcdir%\x64\Release_nologs\module.dll %outdir%\not_logged\Release.x64
xcopy /Y %srcdir%\x64\Release_nologs\loader-test.exe %outdir%\not_logged\Release.x64

xcopy /Y %srcdir%\..\RELEASE_NOTES.txt %outdir%
xcopy /Y %srcdir%\..\readme.user.txt %outdir%

EndLocal